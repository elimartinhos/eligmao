<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { background: black; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; color: white; user-select: none; font-family: sans-serif; overflow: hidden; }
        .panel { width: 380px; height: 600px; background: #1a1a1a; border: 4px solid #333; border-radius: 15px; display: flex; flex-direction: column; align-items: center; padding: 20px; box-sizing: border-box; }
        
        .timer-bar { width: 100%; height: 12px; background: #333; margin-top: 20px; border-radius: 6px; overflow: hidden; border: 1px solid #444; position: relative; }
        #progress { width: 100%; height: 100%; background: #0088ff; transform-origin: left; }

        .grid { display: grid; grid-template-columns: repeat(3, 85px); gap: 15px; margin-top: 50px; position: relative; }

        .io { position: absolute; width: 30px; height: 30px; border-radius: 50%; border: 3px solid #444; transition: 0.3s; }
        .in-azul { left: -45px; top: 25px; background: #0088ff; box-shadow: 0 0 15px #0088ff; } 
        .out-azul { right: -45px; top: 215px; background: transparent; }
        .out-azul.active { background: #0088ff; box-shadow: 0 0 20px #0088ff; border-color: #80c4ff; }

        .pipe { width: 85px; height: 85px; background: #222; border-radius: 10px; display: flex; justify-content: center; align-items: center; transition: 0.3s; border: 2px solid transparent; }
        .t-inner { position: relative; width: 60px; height: 60px; pointer-events: none; transition: transform 0.15s cubic-bezier(0.18, 0.89, 0.32, 1.28); }
        .t-bar, .t-stem { position: absolute; background: #444; border-radius: 6px; transition: background 0.2s, box-shadow 0.2s; }
        .t-bar { top: 25px; left: 0; width: 60px; height: 12px; }
        .t-stem { top: 25px; left: 24px; width: 12px; height: 35px; }

        .matching .t-bar, .matching .t-stem { background: #0088ff !important; box-shadow: 0 0 15px #0088ff; }
        .locked .t-bar, .locked .t-stem { background: #0088ff !important; opacity: 0.8; }
        .current-target { border-color: #0088ff44; background: #222; }

        .status { margin-top: 40px; font-family: monospace; color: #0088ff; font-size: 0.8rem; letter-spacing: 1px; }

        .completed .panel { filter: grayscale(1) opacity(0.3); pointer-events: none; }
        #check-mark { position: absolute; font-size: 15rem; color: #00ff00; display: none; z-index: 100; text-shadow: 0 0 30px rgba(0,255,0,0.5); }
    </style>
</head>
<body>

<div id="check-mark">✓</div>

<div class="panel">
    <div class="timer-bar"><div id="progress"></div></div>
    <div class="status" id="hint">ESTABILIZE O FLUXO...</div>
    
    <div class="grid" id="pipeGrid">
        <div class="io in-azul"></div>
        <div id="out-borne" class="io out-azul"></div>
    </div>
</div>

<script>
    const grid = document.getElementById('pipeGrid');
    const progress = document.getElementById('progress');
    const borne = document.getElementById('out-borne');
    let angles = Array(9).fill(0);
    let solution = [];
    let currentStep = 0;
    let startTime;
    let duration = 2000;
    let timerId;
    let canRotate = true;

    // Criar os elementos da grid uma única vez
    for(let i=0; i<9; i++) {
        const p = document.createElement('div');
        p.className = 'pipe';
        p.id = `p${i}`;
        p.innerHTML = `<div class="t-inner" id="t${i}"><div class="t-bar"></div><div class="t-stem"></div></div>`;
        p.onclick = () => { if(i === currentStep && canRotate) rotate(i); };
        grid.appendChild(p);
    }

    function initPuzzle() {
        cancelAnimationFrame(timerId);
        // Garante que a solução de cada peça nunca seja 0 (posição inicial)
        solution = Array.from({length: 9}, () => Math.floor(Math.random() * 3) + 1);
        solution[0] = 0; // A primeira já começa certa e travada
        
        angles = Array(9).fill(0);
        currentStep = 1; 
        borne.classList.remove('active');
        
        document.querySelectorAll('.pipe').forEach((p, i) => {
            p.classList.remove('matching', 'locked', 'current-target');
            document.getElementById(`t${i}`).style.transform = 'rotate(0deg)';
        });

        document.getElementById('p0').classList.add('locked', 'matching');
        document.getElementById('p1').classList.add('current-target');
        startTimer();
    }

    function rotate(idx) {
        if (navigator.vibrate) navigator.vibrate(15);
        angles[idx] = (angles[idx] + 1) % 4;
        document.getElementById(`t${idx}`).style.transform = `rotate(${angles[idx] * 90}deg)`;
        
        // Só liga o azul se o ângulo for exatamente o da solução
        if (angles[idx] === solution[idx]) {
            document.getElementById(`p${idx}`).classList.add('matching');
        } else {
            document.getElementById(`p${idx}`).classList.remove('matching');
        }
    }

    function startTimer() {
        canRotate = true;
        startTime = performance.now();
        document.getElementById('hint').innerText = `SINCRONIZANDO PASSO ${currentStep}/9...`;
        
        function animate(now) {
            let elapsed = now - startTime;
            let remaining = Math.max(0, 1 - (elapsed / duration));
            progress.style.transform = `scaleX(${remaining})`;
            
            if (elapsed < duration) {
                timerId = requestAnimationFrame(animate);
            } else {
                validateStep();
            }
        }
        timerId = requestAnimationFrame(animate);
    }

    function validateStep() {
        canRotate = false;
        const el = document.getElementById(`p${currentStep}`);
        
        // Validação dupla: ângulo correto E classe matching ativa
        if (angles[currentStep] === solution[currentStep] && el.classList.contains('matching')) {
            el.classList.replace('matching', 'locked');
            el.classList.remove('current-target');
            currentStep++;
            
            if (currentStep === 9) {
                success();
            } else {
                document.getElementById(`p${currentStep}`).classList.add('current-target');
                setTimeout(startTimer, 200);
            }
        } else {
            triggerError();
        }
    }

    function triggerError() {
        if (navigator.vibrate) navigator.vibrate([300, 100, 300]);
        document.getElementById('hint').innerText = "CONEXÃO ROMPIDA!";
        setTimeout(initPuzzle, 600);
    }

    function success() {
        borne.classList.add('active');
        document.getElementById('hint').innerText = "FLUXO ESTABELECIDO";
        if (navigator.vibrate) navigator.vibrate(200);
        
        setTimeout(() => {
            document.body.classList.add('completed');
            document.getElementById('check-mark').style.display = 'block';
            window.parent.postMessage('nextPuzzle', '*');
        }, 1000);
    }

    initPuzzle();
</script>
</body>
</html>