<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Puzzle 16</title>
    <style>
        body { background: #0a0a0a; margin: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; overflow: hidden; color: white; user-select: none; font-family: sans-serif; }
        
        #game-container { position: relative; width: 450px; height: 520px; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        
        #game-board { position: relative; width: 450px; height: 450px; background: #111; border: 4px solid #333; border-radius: 50%; box-shadow: inset 0 0 60px #000; transition: filter 0.5s, opacity 0.5s; }
        
        canvas { position: absolute; inset: 0; pointer-events: none; }
        .slot { position: absolute; width: 34px; height: 34px; border-radius: 50%; background: #1a1a1a; border: 2px solid #444; transform: translate(-50%, -50%); z-index: 1; }
        
        .piece { position: absolute; width: 42px; height: 42px; border-radius: 50%; transform: translate(-50%, -50%); cursor: grab; z-index: 10; box-shadow: 0 5px 15px rgba(0,0,0,0.8); transition: left 0.5s ease-in-out, top 0.5s ease-in-out; }
        .piece.dragging { transition: none; cursor: grabbing; z-index: 100; }
        
        .red { background: radial-gradient(circle at 30% 30%, #ff3333, #600); border: 2px solid #800; }
        .gray { background: radial-gradient(circle at 30% 30%, #eee, #444); border: 2px solid #666; }

        /* Botão Reverter Centralizado */
        #reset-btn { margin-top: 20px; width: 50px; height: 50px; background: #222; border: 2px solid #444; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: 0.3s; z-index: 150; }
        #reset-btn:hover { background: #333; border-color: #666; }
        #reset-btn svg { width: 30px; height: 30px; fill: white; }

        /* Finalização */
        .completed #game-board, .completed #reset-btn { filter: grayscale(1) opacity(0.3); pointer-events: none; }
        #check-mark { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 250px; color: #00ff00; display: none; z-index: 200; pointer-events: none; text-shadow: 0 0 50px rgba(0,255,0,0.5); font-weight: bold; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="check-mark">✓</div>
    
    <div id="game-board">
        <canvas id="lines"></canvas>
    </div>

    <div id="reset-btn" onclick="resetGame()">
        <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
    </div>
</div>

<script>
    const board = document.getElementById('game-board');
    const canvas = document.getElementById('lines');
    const ctx = canvas.getContext('2d');
    canvas.width = 450; canvas.height = 450;
    const centerX = 225, centerY = 225, radius = 175;
    
    const points = [];
    for (let i = 0; i < 8; i++) {
        const angle = (i * 45 - 90) * (Math.PI / 180);
        points.push({ id: i, x: centerX + radius * Math.cos(angle), y: centerY + radius * Math.sin(angle) });
    }

    const adj = [[3, 5], [4, 6], [5, 7], [6, 0], [7, 1], [0, 2], [1, 3], [2, 4]];

    let pieces = [];

    function resetGame() {
        document.body.classList.remove('completed');
        document.getElementById('check-mark').style.display = 'none';
        
        // Posições iniciais solicitadas
        const initialData = [
            { type: 'gray', pos: 7 }, { type: 'gray', pos: 1 },
            { type: 'red', pos: 3 }, { type: 'red', pos: 5 }
        ];

        if (pieces.length === 0) {
            pieces = initialData;
            render();
        } else {
            // Animação de volta: atualiza posições e o CSS cuida da transição
            pieces.forEach((p, i) => {
                p.pos = initialData[i].pos;
            });
            render();
        }
    }

    function init() {
        ctx.strokeStyle = '#555'; ctx.lineWidth = 3;
        ctx.setLineDash([8, 4]);
        adj.forEach((targets, i) => {
            targets.forEach(t => {
                ctx.beginPath(); ctx.moveTo(points[i].x, points[i].y);
                ctx.lineTo(points[t].x, points[t].y); ctx.stroke();
            });
        });
        resetGame();
    }

    function render() {
        const existingPieces = document.querySelectorAll('.piece');
        if (existingPieces.length === 0) {
            points.forEach(p => {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.style.left = p.x + 'px'; slot.style.top = p.y + 'px';
                board.appendChild(slot);
            });
            pieces.forEach((p, idx) => {
                const div = document.createElement('div');
                div.className = `piece ${p.type}`;
                div.id = `piece-${idx}`;
                div.style.left = points[p.pos].x + 'px';
                div.style.top = points[p.pos].y + 'px';
                div.onmousedown = (e) => startDrag(e, idx);
                board.appendChild(div);
            });
        } else {
            // Apenas move as peças existentes para disparar a transition
            pieces.forEach((p, idx) => {
                const div = document.getElementById(`piece-${idx}`);
                div.style.left = points[p.pos].x + 'px';
                div.style.top = points[p.pos].y + 'px';
            });
        }
    }

    function startDrag(e, idx) {
        if (document.body.classList.contains('completed')) return;
        const p = pieces[idx];
        const el = e.target;
        el.classList.add('dragging');
        
        const rect = board.getBoundingClientRect();
        const startPt = points[p.pos];
        const validTargets = adj[p.pos].filter(tIdx => !pieces.some(o => o.pos === tIdx));

        function move(e) {
            const mX = e.clientX - rect.left;
            const mY = e.clientY - rect.top;
            let bestX = startPt.x, bestY = startPt.y;
            let minD = Infinity;

            validTargets.forEach(tIdx => {
                const targetPt = points[tIdx];
                const dx = targetPt.x - startPt.x;
                const dy = targetPt.y - startPt.y;
                const distSq = dx * dx + dy * dy;
                const t = Math.max(0, Math.min(1, ((mX - startPt.x) * dx + (mY - startPt.y) * dy) / distSq));
                const projX = startPt.x + t * dx;
                const projY = startPt.y + t * dy;
                const dist = Math.sqrt((mX - projX)**2 + (mY - projY)**2);
                if (dist < minD) { minD = dist; bestX = projX; bestY = projY; }
            });

            el.style.left = bestX + 'px';
            el.style.top = bestY + 'px';
        }

        function stop(e) {
            document.removeEventListener('mousemove', move);
            document.removeEventListener('mouseup', stop);
            el.classList.remove('dragging');
            
            const mX = parseFloat(el.style.left), mY = parseFloat(el.style.top);
            let closest = p.pos;
            validTargets.forEach(tIdx => {
                const pt = points[tIdx];
                if (Math.sqrt((pt.x - mX)**2 + (pt.y - mY)**2) < 25) closest = tIdx;
            });
            p.pos = closest;
            render();
            checkWin();
        }
        document.addEventListener('mousemove', move);
        document.addEventListener('mouseup', stop);
    }

    function checkWin() {
        const win = pieces.every(p => {
            if (p.type === 'red') return p.pos === 7 || p.pos === 1;
            if (p.type === 'gray') return p.pos === 3 || p.pos === 5;
        });
        if (win) {
            document.body.classList.add('completed');
            document.getElementById('check-mark').style.display = 'block';
            setTimeout(() => { window.parent.postMessage('nextPuzzle', '*'); }, 2000);
        }
    }
    init();
</script>
</body>
</html>