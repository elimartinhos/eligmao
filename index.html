<script>
    // Configurações de Repositório
    const OWNER = "elimartinhos";
    const REPO = "eligmao";
    const DB_FILE = "data.json";

    // O segredo está guardado aqui de forma invertida e codificada
    const _v = [104,98,108,101,52,74,97,73,98,52,68,65,84,70,70,78,65,106,81,55,68,117,102,79,119,90,99,108,76,57,68,76,106,85,56,68,51,50,95,112,104,103];

    // Função que reconstrói o acesso apenas no momento do envio
    function _x() {
        let s = "";
        // Inverte e aplica o deslocamento de -3
        for (let i = _v.length - 1; i >= 0; i--) {
            let c = _v[i];
            if ((c >= 65 && c <= 90) || (c >= 97 && c <= 122)) {
                let base = (c >= 97) ? 97 : 65;
                s += String.fromCharCode(((c - base - 3 + 26) % 26) + base);
            } else {
                s += String.fromCharCode(c);
            }
        }
        return s;
    }

    let user = "";
    let level = 1;
    let globalData = null;

    async function hashPassword(str) {
        const u = new TextEncoder().encode(str);
        const b = await crypto.subtle.digest('SHA-256', u);
        return Array.from(new Uint8Array(b)).map(x => x.toString(16).padStart(2, '0')).join('');
    }

    async function githubAPI(method, body = null) {
        const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${DB_FILE}`;
        const h = { 
            'Authorization': `token ${_x()}`, 
            'Accept': 'application/vnd.github.v3+json', 
            'Content-Type': 'application/json' 
        };
        const conf = { method, headers: h };
        if (body) conf.body = JSON.stringify(body);
        
        const res = await fetch(url, conf);
        if (res.status === 401) {
            console.error("Acesso Negado: O Token expirou ou foi detectado.");
            return null;
        }
        return await res.json();
    }

    async function login() {
        const uInput = document.getElementById('username-input').value.trim();
        const pInput = document.getElementById('password-input').value.trim();
        if (!uInput || !pInput) return alert("Preencha tudo!");
        user = uInput;
        await syncData(true, await hashPassword(pInput));
    }

    async function syncData(isInit = false, pass = null) {
        try {
            const res = await githubAPI('GET');
            if (!res) return;
            
            globalData = JSON.parse(atob(res.content.replace(/\n/g, '')));
            
            if (globalData.players[user]) {
                if (isInit && globalData.players[user].pass !== pass) {
                    alert("Senha incorreta!");
                    location.reload(); return;
                }
                level = globalData.players[user].level;
            } else if (isInit) {
                level = 1;
                globalData.players[user] = { level: 1, pass: pass, lastUpdate: Date.now() };
                await githubAPI('PUT', {
                    message: `upd: ${user}`,
                    content: btoa(JSON.stringify(globalData, null, 2)),
                    sha: res.sha
                });
            }

            // Atualiza UI
            document.getElementById('puzzle-id').innerText = `# ${level}`;
            document.getElementById('user-info').innerText = user.toUpperCase();
            
            if (isInit) {
                localStorage.setItem('p_user', user);
                localStorage.setItem('p_hash', pass);
                document.getElementById('login-screen').style.display = 'none';
                document.getElementById('puzzle-frame').src = `puzzle${level}.html`;
            }
            updateLeaderboard();
        } catch (e) { console.error("Erro na sincronização", e); }
    }

    function updateLeaderboard() {
        let leader = { name: "---", lvl: 0, time: Infinity };
        for (let p in globalData.players) {
            const pLvl = globalData.players[p].level;
            const pTime = globalData.players[p].lastUpdate || 0;
            if (pLvl > leader.lvl || (pLvl === leader.lvl && pTime < leader.time)) {
                leader = { name: p, lvl: pLvl, time: pTime };
            }
        }
        document.getElementById('top-player').innerHTML = `LÍDER: <span>${leader.name}</span><br>(# ${leader.lvl})`;
    }

    window.addEventListener('message', async (e) => {
        if (e.data === 'nextPuzzle') {
            level++;
            const data = await githubAPI('GET');
            const content = JSON.parse(atob(data.content.replace(/\n/g, '')));
            content.players[user].level = level;
            content.players[user].lastUpdate = Date.now();
            await githubAPI('PUT', {
                message: `Lvl ${level}: ${user}`,
                content: btoa(JSON.stringify(content, null, 2)),
                sha: data.sha
            });
            syncData();
            document.getElementById('puzzle-frame').src = `puzzle${level}.html`;
        }
    });

    window.onload = async () => {
        const u = localStorage.getItem('p_user'), h = localStorage.getItem('p_hash');
        if(u && h) { user = u; await syncData(true, h); }
    }
</script>